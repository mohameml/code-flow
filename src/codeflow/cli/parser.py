"""
Command-line argument parser for CodeFlow CLI.

This module handles parsing and validation of command-line arguments,
generating default output paths, and providing helpful error messages.
"""

import argparse
import sys 
from pathlib import Path 
from typing  import Optional

from codeflow.cli.models import CliInput

class Parser :
    """
    Parse and validate command-line arguments for CodeFlow.
    
    This class is responsible for:
    - Parsing command-line arguments into a structured CliInput object
    - Validating that the input file exists and is a Python file
    - Generating sensible default output paths
    - Creating output directories if they don't exist
    - Providing clear error messages for invalid inputs
    
    Usage:
        >>> parser = Parser()
        >>> cli_input = parser.parse()  # Parses sys.argv
        >>> cli_input = parser.parse(["script.py", "--verbose"])  # Custom args
    
    Design:
        The parser uses a two-phase approach:
        1. Parse arguments with argparse (syntactic validation)
        2. Validate the parsed data (semantic validation)
        
        This separation makes the code easier to test and maintain.
    """

    def __init__(self):
        """
        Initialize the Parser.
        
        Creates an argparse.ArgumentParser with all supported options.
        """
        self._parser = self._create_parser()
    
    def _create_parser(self) -> argparse.ArgumentParser : 
        """
        Create and configure the argument parser.
        
        Returns:
            Configured ArgumentParser instance
            
        Design Notes:
            - Uses RawDescriptionHelpFormatter to preserve formatting in epilog
            - Provides examples in the epilog to help users
            - All optional arguments have sensible defaults
        """
        parser = argparse.ArgumentParser(
            prog="codeflow",
            description="Trace Python code execution and visualize call graphs.",
            formatter_class=argparse.RawDescriptionHelpFormatter,
            epilog="""
Examples:
  # Basic usage - generates script.callgraph.png
  codeflow script.py
  
  # Custom PNG output
  codeflow script.py --out-png my-graph.png
  
  # Generate both PNG and JSON
  codeflow script.py --out-json trace.json
  
  # Show the <module> node in the call graph
  codeflow script.py --show-module
  
  # Verbose output with statistics
  codeflow script.py --verbose
  
  # Combine options
  codeflow examples/fib.py --out-png fib.png --out-json fib.json --show-module -v
            """
        )

        # Positional argument: input file
        parser.add_argument(
            "file",
            metavar="FILE",
            help="Python file to trace and analyze"
        )
        
        # Optional: PNG output path
        parser.add_argument(
            "--out-png",
            metavar="PATH",
            default=None,
            help="output PNG file path (default: <FILE>.callgraph.png)"
        )
        
        # Optional: JSON output path
        parser.add_argument(
            "--out-json",
            metavar="PATH",
            nargs='?',  # ðŸ‘ˆ Makes argument optional
            const='auto',  # ðŸ‘ˆ Value if flag is present but no path given
            default=None,
            help="output JSON file path (optional, generated by default : <FILE>.trace.json)"
        )
        
        # Optional: show module node
        parser.add_argument(
            "--show-module",
            action="store_true",
            help="include the <module> node in the call graph visualization"
        )
        
        # Optional: verbose output
        parser.add_argument(
            "-v", "--verbose",
            action="store_true",
            help="display verbose output with execution statistics"
        )
        
        return parser

    def parse(self, args: Optional[list] = None) -> CliInput:
        """
        Parse command-line arguments and return validated CliInput.
        
        This is the main entry point for argument parsing. It:
        1. Parses arguments using argparse
        2. Generates default output paths if not provided
        3. Creates a CliInput object
        4. Validates the input
        
        Args:
            args: List of arguments to parse. If None, uses sys.argv[1:]
                 (this is argparse's default behavior)
            
        Returns:
            Validated CliInput object ready for use
            
        Raises:
            SystemExit: If argument parsing fails (e.g., --help, invalid args)
            FileNotFoundError: If the source file doesn't exist
            ValueError: If validation fails (e.g., not a .py file)
            
        Examples:
            >>> parser = Parser()
            >>> cli_input = parser.parse(["script.py"])
            >>> cli_input.source_file
            'script.py'
            >>> cli_input.output_png
            'script.callgraph.png'
        """
        # Parse arguments (may raise SystemExit for --help or errors)
        try :
            parsed = self._parser.parse_args(args)
        except SystemExit : 
            # Re-raise SystemExit (this is expected for --help, etc.)
            raise

        # Generate default output paths based on input filename
        source_path = Path(parsed.file)
        base_name = source_path.stem # filename wihtout extension  

        # Default PNG : <filename>.callgraph.png in the same directory of filename
        if parsed.out_png : 
            output_png = parsed.out_png 
        else : 
            # If source is in a subdirectory, put output there too 
            output_png = str(source_path.parent / f"{base_name}.callgraph.png")

        # Default josn if the flag --out-json used : 
        if parsed.out_json == 'auto':
            output_json = str(source_path.parent / f"{base_name}.trace.json")
        else:
            output_json = parsed.out_json

        # Create CliInput object
        # The CliInput constructor will validate basic field constraints
        try:
            cli_input = CliInput(
                source_file=str(source_path),
                output_png=output_png,
                output_json=output_json,
                show_module=parsed.show_module,
                verbose=parsed.verbose
            )
        except ValueError as e:
            # CliInput validation failed (should be rare)
            self._parser.error(f"Invalid configuration: {e}")

        # Perform additional semantic validation
        self._validate(cli_input)

        return cli_input

    def _validate(self, cli_input: CliInput) -> None:
        """
        Validate the parsed CLI input for semantic correctness.
        
        This method performs validation that goes beyond what argparse
        can do, such as checking file existence and creating directories.
        
        Args:
            cli_input: The CliInput object to validate
            
        Raises:
            FileNotFoundError: If source file doesn't exist
            ValueError: If source file is not a Python file
            OSError: If output directory cannot be created
            
        Design Notes:
            - We validate that the source file EXISTS (not just that the path is valid)
            - We validate that the source file is a .py file (warn, don't error)
            - We create output directories if they don't exist
            - We don't validate write permissions (that will fail later with a clear error)
        """
        # Validate source file existence
        source_path = Path(cli_input.source_file)
        
        if not source_path.exists():
            raise FileNotFoundError(
                f"Source file not found: {cli_input.source_file}\n"
                f"Please check that the file path is correct."
            )
        
        if not source_path.is_file():
            raise ValueError(
                f"Source path is not a file: {cli_input.source_file}\n"
                f"Please provide a path to a Python file."
            )
        
        # Validate Python file extension (warn but don't error)
        if not source_path.suffix == '.py':
            print(
                f"Warning: File does not have .py extension: {cli_input.source_file}",
                file=sys.stderr
            )
            print(
                f"         CodeFlow will attempt to trace it anyway.",
                file=sys.stderr
            )
        
        # Create output directories if they don't exist
        self._ensure_output_directories(cli_input)

    def _ensure_output_directories(self, cli_input: CliInput) -> None:
        """
        Create output directories if they don't exist.
        
        Args:
            cli_input: The CliInput with output paths
            
        Raises:
            OSError: If directory creation fails due to permissions
            
        Design Notes:
            - We create parent directories for both PNG and JSON outputs
            - We use parents=True to create intermediate directories
            - We use exist_ok=True to avoid errors if directory already exists
            - Current directory ('.') doesn't need to be created
        """
        # PNG output directory 
        png_path = Path(cli_input.output_png)
        png_dir = png_path.parent 

        if png_dir != Path(".") and  not png_dir.exists() : 
            try : 
                png_dir.mkdir(parents=True ,exist_ok=True)
            except OSError as e : 
                raise OSError(
                    f"Failed to create output directory for PNG: {png_dir}\n"
                    f"Error: {e}"
                )

        # JSON output directory (if JSON output is requested)
        if cli_input.output_json : 
            json_path = Path(cli_input.output_json)
            json_dir = json_path.parent 

            if json_path != Path(".") and not json_dir.exists() : 
                try  : 
                    json_dir.mkdir(parents=True , exist_ok=True)
                except OSError as e : 
                    raise OSError(
                        f"Failed to create output directory for JSON: {json_dir}\n"
                        f"Error: {e}"
                    )
                

def parse_args(args: Optional[list] = None) -> CliInput:
    """
    Convenience function for parsing arguments.
    
    This is a shorthand for creating a Parser and calling parse().
    Useful for simple scripts that just want to parse arguments.
    
    Args:
        args: Arguments to parse (None = sys.argv)
        
    Returns:
        Validated CliInput object
        
    Example:
        >>> from codeflow.cli.parser import parse_args
        >>> cli_input = parse_args()  # Parses sys.argv
    """
    parser = Parser()
    return parser.parse(args) 